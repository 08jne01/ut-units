{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"ut-units","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>ut-units is a light weight single header only C++20 compile time unit and dimensional analysis system library. It is heavily inspire by the awesome mp-units.</p> <p>Like mp-units this library allows compile time validation and automatic conversions.</p> <p>The primary motivation for this library to be lightweight: provide fast compile times and zero runtime overhead over using normal scalar types. ut-units also provide readible easy to understand compile time errors. The majority of unit related use cases are covered however if you have very specific requirements the mp-units library is probably more well suited.</p> <p>For the MSVC compiler the requirements for code generation to pass structs by register are extremely strict: ut-units makes sure that even on MSVC unit quantities are passed by register ensure little overhead.</p> <p>See the repository here.</p> <p>See the documentation here.</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Compile time checking</li> <li>Little to no runtime overhead</li> <li>Fast compile times</li> <li>Easily readable compile-time errors</li> <li>Easy to understand syntax</li> <li>Easily extendible with further units</li> </ul>"},{"location":"index.html#examples","title":"Examples","text":""},{"location":"index.html#converting-to-and-from-unit","title":"Converting to and from unit","text":"<p>To convert to a unit from a floating point simply multiply it by the corresponding unit.</p> <pre><code>ut::speed&lt;double&gt; speed = 10.0 * ut::meter_per_second;\n</code></pre> <p>To convert from a unit back to a floating point the <code>in</code> function can be used with a compatible unit.</p> <pre><code>ut::length&lt;double&gt; length = 10.0 * ut::metre;\ndouble length_in_ft_as_double = length.in(ut::foot);\n</code></pre> <p>This makes it easy to interface with existing code that does not use units. See the quantity page for more.</p>"},{"location":"index.html#using-units","title":"Using Units","text":"<p>All the usual operators you would expect are overloaded, operators are appropriately constrained. For example you cannot add metre to a second.</p> <pre><code>ut::time&lt;double&gt; dt; //assume this has a valid value\nut::angle&lt;double&gt; angle; // assume this is some variable we wish to change\n\nut::angular_rate&lt;double&gt; drift_rate = 10.0 * ut::degree / ut::hour;\nangle += dt * drift_rate;\n\nconst double cosa = std::cos( angle ); // dimensionless are implicitly converted to corresponding floating point\n</code></pre>"},{"location":"index.html#gotchas","title":"Gotchas","text":"<p>Care must be taken when creating some quantities as incorrect brackets can lead to unexpected results. This is because operator presedence still applies. Consider the example below</p> <pre><code>ut::angular_rate&lt;double&gt; rate  = 1.0 * ut::degree / ( 2.0 * ut::minute );\nut::angular_rate&lt;double&gt; rate  = 1.0 * ut::degree / 2.0 * ut::minute; // this is the same as 1.0 * ( ut::degree / 2.0) * ut::minute and fails to compile\n</code></pre>"},{"location":"index.html#symbols","title":"Symbols","text":"<p>Short hand symbols are provided for convenient use in the sym namespace.</p> <pre><code>ut::energy&lt;double&gt; energy = 10.0 * sym::kWH\n</code></pre> <p>See the units page for more.</p>"},{"location":"index.html#defining-new-units","title":"Defining New Units","text":"<p>Units can be can create by simply combining existing units. Units are defined using the <code>double</code> type so they can be easily converted to <code>float</code> with the most accurate precision.</p> <pre><code>static constexpr ut::qty newton = ut::kilogram * ut::metre / ( ut::second * ut::second );\nstatic constexpr ut::qty nautical_mile = 1852.0 * ut::metre;\nstatic constexpr ut::qty knot = ut::nautical_mile / ut::hour;\n</code></pre> <p>See the units page for more.</p>"},{"location":"index.html#defining-new-unit-aliases","title":"Defining New Unit Aliases","text":"<p>Unit aliases are names for categories of unit which share the same dimension</p> <pre><code>template&lt;std::floating_point T&gt; using speed = ut::qty&lt;T,decltype(ut::metre_per_second)::dimensions&gt;;\n</code></pre> <p>See the aliases page for more.</p>"},{"location":"index.html#converting-from-double-to-float","title":"Converting from double to float","text":"<p>Units are defined with the <code>double</code> type but can be easily converted <code>float</code>.</p> <pre><code>ut::force&lt;float&gt; force = 100.0f * ut::newton.f();\n</code></pre>"},{"location":"index.html#overhead","title":"Overhead","text":"<p>Since we want this to be as close to a \"zero cost abstraction\" as possible it is important we ensure that the generated code is the same or similar to the equivalent code written as doubles. This is mostly the case when it comes to gcc and clang compilers however the MSVC compiler struggles with this when it comes to passing these units by value.</p> <p>It is expected a struct of 8 bytes be passed in a register and in the best case passed in the xmm registers so it can be used immediately. However the MSVC compiler does not pass any struct in registers if the data is not a plain old data type and the struct does not inherit from anything. The second point is the exact reason that the fundemental type ut::qty does not inherit from anything.</p> <p>Considering all this ut::qty is able to be passed by value in the registers on MSVC however it will use 1 additional instruction to move it from the integer register to an xmm floating pointer register. Moving from the integer register to floating point register is much prefer to behaviour of passing by reference and the cost that incurs with literal types. clang and gcc pass in xmm registers as they seem to understand that ut::qty is just a floating point number.</p> <p>The original purpose for this library was to be built with MSVC so much care has been taken to ensure it is optimal as possible for this compiler.</p>"},{"location":"index.html#contributions","title":"Contributions","text":"<p>Contributions are welcome. There are several ways to contribute:</p> <ul> <li>Adding new units and symbols</li> <li>Adding new aliases</li> <li>Making issues for any bugs discovered.</li> <li>Fixing bugs</li> <li>Adding tests</li> </ul> <p>There are no specific requirements for contributing but for code contributions please match the general style and provide comments with sources for any significant assertions (definition of specific unit for example).</p>"},{"location":"aliases.html","title":"Aliases","text":"<p>While <code>ut::qty</code> is the main type aliases are used to provide a readable interface for specific sets of dimensions. Below are aliases the 7 base dimensions + dimensionless</p> <pre><code>template&lt;std::floating_point T&gt; using dimensionless = qty&lt;T,qty_dimensions&lt;&gt;&gt;;\ntemplate&lt;std::floating_point T&gt; using time          = qty&lt;T,qty_dimensions&lt;1&gt;&gt;;\ntemplate&lt;std::floating_point T&gt; using length        = qty&lt;T,qty_dimensions&lt;0,1&gt;&gt;;\ntemplate&lt;std::floating_point T&gt; using mass          = qty&lt;T,qty_dimensions&lt;0,0,1&gt;&gt;;\ntemplate&lt;std::floating_point T&gt; using current       = qty&lt;T,qty_dimensions&lt;0,0,0,1&gt;&gt;;\ntemplate&lt;std::floating_point T&gt; using temperature   = qty&lt;T,qty_dimensions&lt;0,0,0,0,1&gt;&gt;;\ntemplate&lt;std::floating_point T&gt; using amount        = qty&lt;T,qty_dimensions&lt;0,0,0,0,0,1&gt;&gt;;\ntemplate&lt;std::floating_point T&gt; using luminosity    = qty&lt;T,qty_dimensions&lt;0,0,0,0,0,0,1&gt;&gt;;\n</code></pre> <p>for an understanding of the qty and qty_dimensions see their relevant sections</p>"},{"location":"aliases.html#using-aliases","title":"Using Aliases","text":"<p>Here we will calculate force require for a given acceleration from velocity change and time as an example.</p> <pre><code>ut::speed&lt;double&gt; v0 = 1.0 * ut::metre_per_second;\nut::speed&lt;double&gt; v1 = 10.0 * ut::foot_per_second;\n\nut::time&lt;double&gt; t = 0.1 * ut::minutes;\n\nut::speed&lt;double&gt; dV = v1 - v0; // 2.048 m/s\nut::acceleration&lt;double&gt; a = dV / t; // 0.341 m/s^2\n\nut::mass&lt;double&gt; mass = 24.0 * ut::pound; // \n\nut::force&lt;double&gt; force = mass * a;\n\ndouble force_in_N = a.in(ut::newton); // 3.71\ndouble force_in_lbf = a.in(ut::pound_force); // 0.83\n</code></pre> <p>Aliases are preferable to using <code>ut::qty</code> as with <code>ut::qty</code> you either have to specify dimensions manually or use template type deduction which can result in an unintended unit type. Using an alias constrains the unit the intended dimensions and indicates to the reader what the author intended.</p>"},{"location":"aliases.html#adding-aliases","title":"Adding Aliases","text":"<p>Adding aliases is very simple, the only requirement is an existing unit for the desired alias. Below are some of the aliases for the non-fundamental types</p> <pre><code>// in ut namespace for clarity\ntemplate&lt;std::floating_point T&gt; using speed                 = qty&lt;T,decltype(metre_per_second)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using acceleration          = qty&lt;T,decltype(metre_per_second2)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using force                 = qty&lt;T,decltype(newton)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using energy                = qty&lt;T,decltype(joule)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using power                 = qty&lt;T,decltype(watt)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using volume                = qty&lt;T,decltype(litre)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using pressure              = qty&lt;T,decltype(pascal)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using torque                = qty&lt;T,decltype(newton_metre)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using area                  = qty&lt;T,decltype(metre2)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using angular_rate          = qty&lt;T,decltype(radian_per_second)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using angular_acceleration  = qty&lt;T,decltype(radian_per_second2)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using frequency             = qty&lt;T,decltype(hertz)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using mass_flow_rate        = qty&lt;T,decltype(kilogram_per_second)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using moment_of_inertia     = qty&lt;T,decltype(kilogram_metre2)::dimensions&gt;;\ntemplate&lt;std::floating_point T&gt; using density               = qty&lt;T,decltype(kilogram_per_metre3)::dimensions&gt;;\n</code></pre> <p>If you think there should be an alias added please feel free to contribute.</p>"},{"location":"functions.html","title":"Functions","text":"<p>There are lots of operators and some free functions which are compatible with <code>ut::qty</code>.</p> <p>There are several helper structs which provide information for return types</p> type description <code>qty_multiply&lt;scalar_t, dim_left, dim_right&gt;</code> qty result multiply of <code>dim_left</code> and <code>dim_right</code> <code>qty_divide&lt;scalar_t, dim_left, dim_right&gt;</code> qty result divide of <code>dim_left</code> by <code>dim_right</code> <code>qty_sqrt&lt;scalar_t, dim&gt;</code> qty result sqrt of <code>dim</code> <code>qty_pow&lt;scalar_t, dim&gt;</code> qty result pow of <code>dim</code> <code>qty_offset_to_qty&lt;qty_offset&gt;</code> qty result conversion from <code>qty_offset</code> <p>Simplified syntax (pseudocode) is used for function descriptions to aid in reading.</p>"},{"location":"functions.html#operators","title":"Operators","text":"<p>Operators which multiply or divide with a quantity in both operands produce a corresponding quantity given by the helper struct, for example operator* uses <code>qty_multiply</code>. Operators which have a quantity for both operands and do not divide require that <code>compatible_qty&lt;left,right&gt;</code> is true. This concept is defined as follows:</p> <pre><code>template&lt;typename T1, typename T2&gt;\nconcept compatible_qty = requires() {\n    requires qty_type&lt;T1&gt;;\n    requires qty_type&lt;T2&gt;;\n    requires std::same_as&lt;typename T1::type, typename T2::type&gt;;\n    requires same_dimensions&lt;typename T1::dimensions, typename T2::dimensions&gt;::value;\n};\n</code></pre>"},{"location":"functions.html#free-functions","title":"Free Functions","text":""},{"location":"functions.html#sqrt","title":"sqrt","text":"<pre><code>qty_sqrt&lt;scalar_t, qty_type::dimensions&gt; sqrt( qty_type quantity );\n</code></pre> <p>returns <code>sqrt(quantity)</code> if it is square-rootable otherwise compile error</p>"},{"location":"functions.html#pow","title":"pow","text":"<pre><code>template&lt;int N&gt;\nqty_pow&lt;scalar_t, qty_type::dimensions&gt; pow( qty_type quantity );\n</code></pre> <p>returns <code>quantity^N</code></p>"},{"location":"functions.html#abs","title":"abs","text":"<pre><code>type abs( type quantity );\n</code></pre> <p>returns absolute value of <code>type</code>, <code>type</code> can be either scalar or quantity</p>"},{"location":"functions.html#copysign","title":"copysign","text":"<pre><code>type_number copysign(type_number number, type_sign sign);\n</code></pre> <p>returns copies sign of <code>sign</code> onto <code>number</code>, <code>type_number</code> and <code>type_sign</code> can one of scalar or quantity</p>"},{"location":"quantity.html","title":"Quantity","text":""},{"location":"quantity.html#introduction","title":"Introduction","text":"<p><code>ut::qty</code> is the core type of the ut-units library. It describes a value and its dimensions (stored as the type). Internally <code>ut::qty</code> stores its value in base SI units. This means conversions happen at compile time or when the in function is explicitly used.</p>"},{"location":"quantity.html#unit-definitions","title":"Unit definitions","text":"<p>Units are defined as a <code>constexpr ut::qty</code> this means that new units can easily be defined by combining other units. Since the units stored value is ratio of this unit to that of its equivalent unit in base SI units.</p> <p>This is covered more in the units section.</p>"},{"location":"quantity.html#qty","title":"qty","text":"<p>Below is the definition of <code>ut::qty</code></p> <pre><code>template&lt;\n    std::floating_point T,\n    typename TyDimensions = qty_dimensions&lt;&gt;\n&gt;\nstruct qty;\n</code></pre> <p><code>T</code> is the scalar and this must be a floating point type.</p> <p><code>TyDimensions</code> is an instance of <code>ut::qty_dimensions</code> with the dimensions specialised. This encodes the dimensions into the type as a set of integers representing the powers of each type.</p> <p>Floating point types cannot be implicitly converted to <code>ut::qty</code> even if the quantity is dimensionless. This is by design. However <code>ut::qty</code> can be implicitly converted back to a floating point if the quantity is dimensionless, see operator T.</p> <p>Below are a list of all the members of qty.</p>"},{"location":"quantity.html#qty_dimensions","title":"qty_dimensions","text":"<p><code>qty_dimensions</code> specifies the dimensions for this type. Below is the definition.</p> <pre><code>template&lt;\n    int second = 0, \n    int metre = 0,\n    int kilogram = 0,\n    int ampere = 0,\n    int kelvin = 0,\n    int mole = 0,\n    int candela = 0\n&gt;\nstruct qty_dimensions\n{\n    static constexpr int d_second = second;\n    static constexpr int d_metre = metre;\n    static constexpr int d_kilogram = kilogram;\n    static constexpr int d_ampere = ampere;\n    static constexpr int d_kelvin = kelvin;\n    static constexpr int d_mole = mole;\n    static constexpr int d_candela = candela;\n};\n</code></pre> <p>each of the 7 fundemental dimensions are specified by an integer indicating the power. For example the dimensions LT^-2 is indicated by <code>qty_dimensions&lt;-2,1&gt;</code>.</p>"},{"location":"quantity.html#members","title":"Members","text":""},{"location":"quantity.html#in","title":"in","text":"<pre><code>scalar_t qty&lt;scalar_t,dimensions&gt;::in(qty&lt;scalar_t,dimensions&gt; other) const;\n</code></pre> <p>returns quantity as <code>scalar_t</code> (double or float) converted to the corresponding unit <code>other</code></p> <pre><code>scalar_t qty&lt;scalar_t,dimensions&gt;::in(qty_offset&lt;scalar_t,dimensions&gt; other) const;\n</code></pre> <p>see Quantity Offset section</p>"},{"location":"quantity.html#cast","title":"cast","text":"<pre><code>qty&lt;new_scalar_t, dimensions&gt; qty&lt;scalar_t,dimensions&gt;::cast() const; \n</code></pre> <p>returns quantity with new scalar type <code>new_scalar_t</code> by using static_cast on the underlying <code>scalar_t</code></p>"},{"location":"quantity.html#f","title":"f","text":"<pre><code>qty&lt;float,dimensions&gt; qty&lt;scalar_t, dimensions&gt;::f() const;\n</code></pre> <p>returns quantity with new scalar type <code>float</code> by using static_cast on the underlying <code>scalar_t</code>, equivalent to <code>qty::cast&lt;float&gt;()</code></p>"},{"location":"quantity.html#value","title":"value","text":"<pre><code>qty&lt;scalar_t,dimensions&gt;::value\n</code></pre> <p>this is the internal <code>scalar_t</code> value store by <code>qty</code>. It is exposed for use with interfaces requiring a <code>scalar_t&amp;</code>, otherwise it is advisable to use the in function instead as this provides unit safety whereas direct value access does not.</p>"},{"location":"quantity.html#operator-t","title":"operator T","text":"<pre><code>qty&lt;scalar_t,dimensions&gt;::operator scalar_t() const;\n</code></pre> <p>returns internal SI value as <code>scalar_t</code> if implicit conversion is satisfied</p> <p>requires dimensions are dimensionless</p>"},{"location":"quantity.html#operator-qty","title":"operator qty","text":"<pre><code>qty&lt;scalar_t,dimensions&gt;::operator qty&lt;new_scalar_t,new_dimensions&gt;() const;\n</code></pre> <p>this operator is always invalid and is provided to allow readable compile errors when assiging mismatched dimensions</p> <p>requires <code>qty&lt;scalar,dimensions&gt; != qty&lt;new_scalar_t, new_dimensions&gt;</code>, this enables normal assignment when they are the same type</p>"},{"location":"quantity.html#quantity-offset","title":"Quantity Offset","text":"<p>These are a special case for offset quantities such as temperature. ut-units generally only handles ratios however the <code>qty_offset</code> type is provided for special cases. If you need better handling of such units the mp-units library may be better suited.</p> <p>Only one operator is provided for <code>qty_offset</code></p> <pre><code>template&lt;std::floating_point T, typename TyDimension&gt;\nconstexpr qty&lt;T,TyDimension&gt; operator*(T left, qty_offset&lt;T,TyDimension&gt; right)\n</code></pre> <p>this allows conversion from a scalar type to a regular quantity using a <code>qty_offset</code>. Regular quantities can also be converted to an offset unit as a scalar using a <code>qty_offset</code>.</p> <pre><code>// operator* converts from celsius to kelvin SI unit\nut::temperature&lt;double&gt; T = 10.0 * ut::celsius;\n\n// ut::fahrenheit is a qty_offset\ndouble T_in_fahrenheit = T.in( ut::fahrenheit );\n</code></pre>"},{"location":"units.html","title":"Units","text":"<p>Units are defined by a <code>static constexpr ut::qty</code>. Units can be easily created by combining units mathetmatically the same way they are used at run time.</p> <p>Units store the ratio between their unit and the equivalent SI base unit. For example</p> <pre><code>// ratio := 0.3048\nstatic constexpr double ratio = ut::foot_per_second.value;\n</code></pre> <p>This means all units store their value in SI base units under the hood this prevents uncessary conversions between different unit types.</p>"},{"location":"units.html#defining-a-unit","title":"Defining a Unit","text":"<p>Defining a unit is as simple as mathematically combining existing units</p> <pre><code>// here ut namespace is used for clarity\nstatic constexpr qty minute                 = 60.0 * second;\nstatic constexpr qty hour                   = 60.0 * minute;\nstatic constexpr qty kilometre              = 1000.0 * metre;\nstatic constexpr qty milimetre              = 1.0e-3 * metre;\nstatic constexpr qty centimetre             = 1.0e-2 * metre;\nstatic constexpr qty decimetre              = 0.1 * metre;\nstatic constexpr qty newton                 = kilogram * metre / ( second * second );\n</code></pre> <p>for non-SI units they can be defined by their official ratio to the SI units</p> <pre><code>// here ut namespace is used for clarity\nstatic constexpr qty foot                   = 0.3048 * metre;\nstatic constexpr qty inch                   = 25.4 * milimetre;\nstatic constexpr qty nautical_mile          = 1852.0 * metre;\nstatic constexpr qty yard                   = 3.0 * foot;\nstatic constexpr qty mile                   = 5280.0 * foot;\n\nstatic constexpr qty pound                  = 0.453592 * kilogram;\nstatic constexpr qty pound_force            = 4.448222 * newton;\nstatic constexpr qty rankine                = (5.0 / 9.0) * kelvin;\nstatic constexpr qty knot                   = nautical_mile / hour;\nstatic constexpr qty gallon                 = 3.785411784 * litre; // US gallon\nstatic constexpr qty imperial_gallon        = 4.54609 * litre;\nstatic constexpr qty quart                  = 0.946352946 * litre;\n</code></pre> <p>If you think there should be any units added please feel free to contribute.</p>"},{"location":"units.html#symbols","title":"Symbols","text":"<p>Symbols are just aliases (constexpr copies) of their verbose unit counter parts. Below is a list of some of the units defined. For a complete list it is better to check the source file for the sym namespace directly. If you think there should be any symbols added please feel free to contribute.</p> <pre><code>namespace sym\n{\n    // SI Units\n    // &lt;https://en.wikipedia.org/wiki/International_System_of_Units&gt;\n\n    static constexpr auto s         = ut::second;\n    static constexpr auto m         = ut::metre;\n    static constexpr auto kg        = ut::kilogram;\n    static constexpr auto A         = ut::ampere;\n    static constexpr auto K         = ut::kelvin;\n    static constexpr auto mol       = ut::mole;\n    static constexpr auto cd        = ut::candela;\n\n    static constexpr auto rad       = ut::radian;\n    static constexpr auto Hz        = ut::hertz;\n    static constexpr auto N         = ut::newton;\n    static constexpr auto pa        = ut::pascal;\n    static constexpr auto j         = ut::joule;\n    static constexpr auto W         = ut::watt;\n    static constexpr auto kW        = ut::kilowatt;\n    static constexpr auto kWH       = ut::kilowatt_hour;\n\n    static constexpr auto C         = ut::coulomb;\n    static constexpr auto V         = ut::volt;\n    static constexpr auto F         = ut::farad;\n\n    static constexpr auto mm        = ut::milimetre;\n    static constexpr auto km        = ut::kilogram;\n    static constexpr auto degC      = ut::celsius;\n    static constexpr auto kgps      = ut::kilogram_per_second;\n    static constexpr auto kgpm3     = ut::kilogram_per_metre3;\n\n\n    static constexpr auto m2        = ut::metre2;\n    static constexpr auto L         = ut::litre;\n\n    static constexpr auto deg       = ut::degree;\n    static constexpr auto degps     = ut::degree_per_second;\n    static constexpr auto radps     = ut::radian_per_second;\n    static constexpr auto rps       = ut::revolution_per_second;\n    static constexpr auto rpm       = ut::revolution_per_minute;\n\n    static constexpr auto kgm2      = ut::kilogram_metre2;\n\n    // International Units\n    // https://en.wikipedia.org/wiki/United_States_customary_units\n    static constexpr auto nmi       = ut::nautical_mile;\n    static constexpr auto ft        = ut::foot;\n    static constexpr auto mi        = ut::mile;\n    static constexpr auto yd        = ut::yard;\n    static constexpr auto lb        = ut::pound;\n    static constexpr auto lbf       = ut::pound_force;\n    static constexpr auto gal       = ut::gallon;\n    static constexpr auto qt        = ut::quart;\n    static constexpr auto kt        = ut::knot;\n    static constexpr auto psi       = ut::pound_per_square_inch;\n    static constexpr auto fps       = ut::foot_per_second;\n    static constexpr auto degF      = ut::fahrenheit;\n    static constexpr auto pph       = ut::pound_per_hour;\n}\n</code></pre>"}]}